// Code is generated by go generate. DO NOT EDIT.
package keibi

import (
	"context"
	"github.com/turbot/steampipe-plugin-sdk/plugin"
	azure "gitlab.com/keibiengine/keibi-engine/pkg/azure/model"
)

// ==========================  START: APIManagement =============================

type APIManagement struct {
	Description azure.APIManagementDescription `json:"description"`
	Metadata    azure.Metadata                 `json:"metadata"`
}

type APIManagementHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  APIManagement `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type APIManagementHits struct {
	Total SearchTotal        `json:"total"`
	Hits  []APIManagementHit `json:"hits"`
}

type APIManagementSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  APIManagementHits `json:"hits"`
}

type APIManagementPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewAPIManagementPaginator(filters []BoolFilter, limit *int64) (APIManagementPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_apimanagement_service", filters, limit)
	if err != nil {
		return APIManagementPaginator{}, err
	}

	p := APIManagementPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p APIManagementPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *APIManagementPaginator) NextPage(ctx context.Context) ([]APIManagement, error) {
	var response APIManagementSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []APIManagement
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listAPIManagementFilters = map[string]string{}

func ListAPIManagement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAPIManagement")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewAPIManagementPaginator(buildFilter(d.KeyColumnQuals, listAPIManagementFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAPIManagementFilters = map[string]string{
	"name":           "description.APIManagement.Name",
	"resource_group": "description.ResourceGroup",
}

func GetAPIManagement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAPIManagement")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAPIManagementPaginator(buildFilter(d.KeyColumnQuals, getAPIManagementFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: APIManagement =============================

// ==========================  START: AppConfiguration =============================

type AppConfiguration struct {
	Description azure.AppConfigurationDescription `json:"description"`
	Metadata    azure.Metadata                    `json:"metadata"`
}

type AppConfigurationHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AppConfiguration `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AppConfigurationHits struct {
	Total SearchTotal           `json:"total"`
	Hits  []AppConfigurationHit `json:"hits"`
}

type AppConfigurationSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AppConfigurationHits `json:"hits"`
}

type AppConfigurationPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewAppConfigurationPaginator(filters []BoolFilter, limit *int64) (AppConfigurationPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_appconfiguration_configurationstores", filters, limit)
	if err != nil {
		return AppConfigurationPaginator{}, err
	}

	p := AppConfigurationPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p AppConfigurationPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *AppConfigurationPaginator) NextPage(ctx context.Context) ([]AppConfiguration, error) {
	var response AppConfigurationSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listAppConfigurationFilters = map[string]string{}

func ListAppConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppConfiguration")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewAppConfigurationPaginator(buildFilter(d.KeyColumnQuals, listAppConfigurationFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppConfigurationFilters = map[string]string{
	"name":           "description.ConfigurationStore.Name",
	"resource_group": "description.ResourceGroup",
}

func GetAppConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppConfiguration")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppConfigurationPaginator(buildFilter(d.KeyColumnQuals, getAppConfigurationFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppConfiguration =============================

// ==========================  START: AppServiceEnvironment =============================

type AppServiceEnvironment struct {
	Description azure.AppServiceEnvironmentDescription `json:"description"`
	Metadata    azure.Metadata                         `json:"metadata"`
}

type AppServiceEnvironmentHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AppServiceEnvironment `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AppServiceEnvironmentHits struct {
	Total SearchTotal                `json:"total"`
	Hits  []AppServiceEnvironmentHit `json:"hits"`
}

type AppServiceEnvironmentSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AppServiceEnvironmentHits `json:"hits"`
}

type AppServiceEnvironmentPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewAppServiceEnvironmentPaginator(filters []BoolFilter, limit *int64) (AppServiceEnvironmentPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_web_hostingenvironments", filters, limit)
	if err != nil {
		return AppServiceEnvironmentPaginator{}, err
	}

	p := AppServiceEnvironmentPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p AppServiceEnvironmentPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *AppServiceEnvironmentPaginator) NextPage(ctx context.Context) ([]AppServiceEnvironment, error) {
	var response AppServiceEnvironmentSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceEnvironmentFilters = map[string]string{}

func ListAppServiceEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceEnvironment")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewAppServiceEnvironmentPaginator(buildFilter(d.KeyColumnQuals, listAppServiceEnvironmentFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppServiceEnvironmentFilters = map[string]string{
	"name":           "description.AppServiceEnvironmentResource.Name",
	"resource_group": "description.ResourceGroup",
}

func GetAppServiceEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceEnvironment")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppServiceEnvironmentPaginator(buildFilter(d.KeyColumnQuals, getAppServiceEnvironmentFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppServiceEnvironment =============================

// ==========================  START: AppServiceFunctionApp =============================

type AppServiceFunctionApp struct {
	Description azure.AppServiceFunctionAppDescription `json:"description"`
	Metadata    azure.Metadata                         `json:"metadata"`
}

type AppServiceFunctionAppHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AppServiceFunctionApp `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AppServiceFunctionAppHits struct {
	Total SearchTotal                `json:"total"`
	Hits  []AppServiceFunctionAppHit `json:"hits"`
}

type AppServiceFunctionAppSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AppServiceFunctionAppHits `json:"hits"`
}

type AppServiceFunctionAppPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewAppServiceFunctionAppPaginator(filters []BoolFilter, limit *int64) (AppServiceFunctionAppPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_web_sites", filters, limit)
	if err != nil {
		return AppServiceFunctionAppPaginator{}, err
	}

	p := AppServiceFunctionAppPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p AppServiceFunctionAppPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *AppServiceFunctionAppPaginator) NextPage(ctx context.Context) ([]AppServiceFunctionApp, error) {
	var response AppServiceFunctionAppSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceFunctionApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceFunctionAppFilters = map[string]string{}

func ListAppServiceFunctionApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceFunctionApp")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewAppServiceFunctionAppPaginator(buildFilter(d.KeyColumnQuals, listAppServiceFunctionAppFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppServiceFunctionAppFilters = map[string]string{
	"name":           "description.Site.Name",
	"resource_group": "description.ResourceGroup",
}

func GetAppServiceFunctionApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceFunctionApp")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppServiceFunctionAppPaginator(buildFilter(d.KeyColumnQuals, getAppServiceFunctionAppFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppServiceFunctionApp =============================

// ==========================  START: ComputeDisk =============================

type ComputeDisk struct {
	Description azure.ComputeDiskDescription `json:"description"`
	Metadata    azure.Metadata               `json:"metadata"`
}

type ComputeDiskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ComputeDisk   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ComputeDiskHits struct {
	Total SearchTotal      `json:"total"`
	Hits  []ComputeDiskHit `json:"hits"`
}

type ComputeDiskSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  ComputeDiskHits `json:"hits"`
}

type ComputeDiskPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewComputeDiskPaginator(filters []BoolFilter, limit *int64) (ComputeDiskPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_compute_disks", filters, limit)
	if err != nil {
		return ComputeDiskPaginator{}, err
	}

	p := ComputeDiskPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p ComputeDiskPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *ComputeDiskPaginator) NextPage(ctx context.Context) ([]ComputeDisk, error) {
	var response ComputeDiskSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDisk
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskFilters = map[string]string{}

func ListComputeDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDisk")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewComputeDiskPaginator(buildFilter(d.KeyColumnQuals, listComputeDiskFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskFilters = map[string]string{
	"name":           "description.Disk.Name",
	"resource_group": "description.ResourceGroup",
}

func GetComputeDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDisk")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeDiskPaginator(buildFilter(d.KeyColumnQuals, getComputeDiskFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDisk =============================

// ==========================  START: ComputeDiskAccess =============================

type ComputeDiskAccess struct {
	Description azure.ComputeDiskAccessDescription `json:"description"`
	Metadata    azure.Metadata                     `json:"metadata"`
}

type ComputeDiskAccessHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ComputeDiskAccess `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ComputeDiskAccessHits struct {
	Total SearchTotal            `json:"total"`
	Hits  []ComputeDiskAccessHit `json:"hits"`
}

type ComputeDiskAccessSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ComputeDiskAccessHits `json:"hits"`
}

type ComputeDiskAccessPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewComputeDiskAccessPaginator(filters []BoolFilter, limit *int64) (ComputeDiskAccessPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_compute_diskaccesses", filters, limit)
	if err != nil {
		return ComputeDiskAccessPaginator{}, err
	}

	p := ComputeDiskAccessPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p ComputeDiskAccessPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *ComputeDiskAccessPaginator) NextPage(ctx context.Context) ([]ComputeDiskAccess, error) {
	var response ComputeDiskAccessSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskAccess
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskAccessFilters = map[string]string{}

func ListComputeDiskAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskAccess")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewComputeDiskAccessPaginator(buildFilter(d.KeyColumnQuals, listComputeDiskAccessFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskAccessFilters = map[string]string{
	"name":           "description.DiskAccess.Name",
	"resource_group": "description.ResourceGroup",
}

func GetComputeDiskAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskAccess")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeDiskAccessPaginator(buildFilter(d.KeyColumnQuals, getComputeDiskAccessFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskAccess =============================

// ==========================  START: ComputeVirtualMachineScaleSet =============================

type ComputeVirtualMachineScaleSet struct {
	Description azure.ComputeVirtualMachineScaleSetDescription `json:"description"`
	Metadata    azure.Metadata                                 `json:"metadata"`
}

type ComputeVirtualMachineScaleSetHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  ComputeVirtualMachineScaleSet `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type ComputeVirtualMachineScaleSetHits struct {
	Total SearchTotal                        `json:"total"`
	Hits  []ComputeVirtualMachineScaleSetHit `json:"hits"`
}

type ComputeVirtualMachineScaleSetSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  ComputeVirtualMachineScaleSetHits `json:"hits"`
}

type ComputeVirtualMachineScaleSetPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewComputeVirtualMachineScaleSetPaginator(filters []BoolFilter, limit *int64) (ComputeVirtualMachineScaleSetPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_compute_virtualmachinescalesets", filters, limit)
	if err != nil {
		return ComputeVirtualMachineScaleSetPaginator{}, err
	}

	p := ComputeVirtualMachineScaleSetPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineScaleSetPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *ComputeVirtualMachineScaleSetPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineScaleSet, error) {
	var response ComputeVirtualMachineScaleSetSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineScaleSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineScaleSetFilters = map[string]string{}

func ListComputeVirtualMachineScaleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineScaleSet")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewComputeVirtualMachineScaleSetPaginator(buildFilter(d.KeyColumnQuals, listComputeVirtualMachineScaleSetFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineScaleSetFilters = map[string]string{
	"name":           "description.VirtualMachineScaleSet.Name",
	"resource_group": "description.ResourceGroup",
}

func GetComputeVirtualMachineScaleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineScaleSet")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineScaleSetPaginator(buildFilter(d.KeyColumnQuals, getComputeVirtualMachineScaleSetFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineScaleSet =============================

// ==========================  START: DataboxEdgeDevice =============================

type DataboxEdgeDevice struct {
	Description azure.DataboxEdgeDeviceDescription `json:"description"`
	Metadata    azure.Metadata                     `json:"metadata"`
}

type DataboxEdgeDeviceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DataboxEdgeDevice `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DataboxEdgeDeviceHits struct {
	Total SearchTotal            `json:"total"`
	Hits  []DataboxEdgeDeviceHit `json:"hits"`
}

type DataboxEdgeDeviceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DataboxEdgeDeviceHits `json:"hits"`
}

type DataboxEdgeDevicePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewDataboxEdgeDevicePaginator(filters []BoolFilter, limit *int64) (DataboxEdgeDevicePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_databoxedge_databoxedgedevices", filters, limit)
	if err != nil {
		return DataboxEdgeDevicePaginator{}, err
	}

	p := DataboxEdgeDevicePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p DataboxEdgeDevicePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *DataboxEdgeDevicePaginator) NextPage(ctx context.Context) ([]DataboxEdgeDevice, error) {
	var response DataboxEdgeDeviceSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataboxEdgeDevice
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listDataboxEdgeDeviceFilters = map[string]string{}

func ListDataboxEdgeDevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataboxEdgeDevice")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewDataboxEdgeDevicePaginator(buildFilter(d.KeyColumnQuals, listDataboxEdgeDeviceFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataboxEdgeDeviceFilters = map[string]string{
	"name":           "description.Device.Name",
	"resource_group": "description.ResourceGroup",
}

func GetDataboxEdgeDevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataboxEdgeDevice")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataboxEdgeDevicePaginator(buildFilter(d.KeyColumnQuals, getDataboxEdgeDeviceFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataboxEdgeDevice =============================

// ==========================  START: HealthcareService =============================

type HealthcareService struct {
	Description azure.HealthcareServiceDescription `json:"description"`
	Metadata    azure.Metadata                     `json:"metadata"`
}

type HealthcareServiceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  HealthcareService `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type HealthcareServiceHits struct {
	Total SearchTotal            `json:"total"`
	Hits  []HealthcareServiceHit `json:"hits"`
}

type HealthcareServiceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  HealthcareServiceHits `json:"hits"`
}

type HealthcareServicePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewHealthcareServicePaginator(filters []BoolFilter, limit *int64) (HealthcareServicePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_healthcareapis_services", filters, limit)
	if err != nil {
		return HealthcareServicePaginator{}, err
	}

	p := HealthcareServicePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p HealthcareServicePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *HealthcareServicePaginator) NextPage(ctx context.Context) ([]HealthcareService, error) {
	var response HealthcareServiceSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HealthcareService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listHealthcareServiceFilters = map[string]string{}

func ListHealthcareService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHealthcareService")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewHealthcareServicePaginator(buildFilter(d.KeyColumnQuals, listHealthcareServiceFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHealthcareServiceFilters = map[string]string{
	"name":           "description.ServicesDescription.Name",
	"resource_group": "description.ResourceGroup",
}

func GetHealthcareService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHealthcareService")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHealthcareServicePaginator(buildFilter(d.KeyColumnQuals, getHealthcareServiceFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HealthcareService =============================

// ==========================  START: HpcCache =============================

type HpcCache struct {
	Description azure.HpcCacheDescription `json:"description"`
	Metadata    azure.Metadata            `json:"metadata"`
}

type HpcCacheHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  HpcCache      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type HpcCacheHits struct {
	Total SearchTotal   `json:"total"`
	Hits  []HpcCacheHit `json:"hits"`
}

type HpcCacheSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  HpcCacheHits `json:"hits"`
}

type HpcCachePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewHpcCachePaginator(filters []BoolFilter, limit *int64) (HpcCachePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_storagecache_caches", filters, limit)
	if err != nil {
		return HpcCachePaginator{}, err
	}

	p := HpcCachePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p HpcCachePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *HpcCachePaginator) NextPage(ctx context.Context) ([]HpcCache, error) {
	var response HpcCacheSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HpcCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listHpcCacheFilters = map[string]string{}

func ListHpcCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHpcCache")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewHpcCachePaginator(buildFilter(d.KeyColumnQuals, listHpcCacheFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHpcCacheFilters = map[string]string{
	"name":           "description.Cache.Name",
	"resource_group": "description.ResourceGroup",
}

func GetHpcCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHpcCache")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHpcCachePaginator(buildFilter(d.KeyColumnQuals, getHpcCacheFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HpcCache =============================

// ==========================  START: KeyVaultKey =============================

type KeyVaultKey struct {
	Description azure.KeyVaultKeyDescription `json:"description"`
	Metadata    azure.Metadata               `json:"metadata"`
}

type KeyVaultKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KeyVaultKey   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KeyVaultKeyHits struct {
	Total SearchTotal      `json:"total"`
	Hits  []KeyVaultKeyHit `json:"hits"`
}

type KeyVaultKeySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  KeyVaultKeyHits `json:"hits"`
}

type KeyVaultKeyPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewKeyVaultKeyPaginator(filters []BoolFilter, limit *int64) (KeyVaultKeyPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_keyvault_vaults", filters, limit)
	if err != nil {
		return KeyVaultKeyPaginator{}, err
	}

	p := KeyVaultKeyPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p KeyVaultKeyPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *KeyVaultKeyPaginator) NextPage(ctx context.Context) ([]KeyVaultKey, error) {
	var response KeyVaultKeySearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultKeyFilters = map[string]string{}

func ListKeyVaultKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultKey")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewKeyVaultKeyPaginator(buildFilter(d.KeyColumnQuals, listKeyVaultKeyFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyVaultKeyFilters = map[string]string{
	"name":           "description.Cache.Name",
	"resource_group": "description.ResourceGroup",
	"vault_name":     "",
}

func GetKeyVaultKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultKey")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultKeyPaginator(buildFilter(d.KeyColumnQuals, getKeyVaultKeyFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyVaultKey =============================

// ==========================  START: KubernetesCluster =============================

type KubernetesCluster struct {
	Description azure.KubernetesClusterDescription `json:"description"`
	Metadata    azure.Metadata                     `json:"metadata"`
}

type KubernetesClusterHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  KubernetesCluster `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type KubernetesClusterHits struct {
	Total SearchTotal            `json:"total"`
	Hits  []KubernetesClusterHit `json:"hits"`
}

type KubernetesClusterSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  KubernetesClusterHits `json:"hits"`
}

type KubernetesClusterPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewKubernetesClusterPaginator(filters []BoolFilter, limit *int64) (KubernetesClusterPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_containerservice_managedclusters", filters, limit)
	if err != nil {
		return KubernetesClusterPaginator{}, err
	}

	p := KubernetesClusterPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p KubernetesClusterPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *KubernetesClusterPaginator) NextPage(ctx context.Context) ([]KubernetesCluster, error) {
	var response KubernetesClusterSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KubernetesCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listKubernetesClusterFilters = map[string]string{}

func ListKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKubernetesCluster")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewKubernetesClusterPaginator(buildFilter(d.KeyColumnQuals, listKubernetesClusterFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKubernetesClusterFilters = map[string]string{
	"name":           "description.ManagedCluster.Name",
	"resource_group": "description.ResourceGroup",
}

func GetKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKubernetesCluster")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKubernetesClusterPaginator(buildFilter(d.KeyColumnQuals, getKubernetesClusterFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KubernetesCluster =============================

// ==========================  START: NetworkInterface =============================

type NetworkInterface struct {
	Description azure.NetworkInterfaceDescription `json:"description"`
	Metadata    azure.Metadata                    `json:"metadata"`
}

type NetworkInterfaceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  NetworkInterface `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type NetworkInterfaceHits struct {
	Total SearchTotal           `json:"total"`
	Hits  []NetworkInterfaceHit `json:"hits"`
}

type NetworkInterfaceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  NetworkInterfaceHits `json:"hits"`
}

type NetworkInterfacePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewNetworkInterfacePaginator(filters []BoolFilter, limit *int64) (NetworkInterfacePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_network_networkinterfaces", filters, limit)
	if err != nil {
		return NetworkInterfacePaginator{}, err
	}

	p := NetworkInterfacePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p NetworkInterfacePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *NetworkInterfacePaginator) NextPage(ctx context.Context) ([]NetworkInterface, error) {
	var response NetworkInterfaceSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkInterface
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkInterfaceFilters = map[string]string{}

func ListNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkInterface")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewNetworkInterfacePaginator(buildFilter(d.KeyColumnQuals, listNetworkInterfaceFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkInterfaceFilters = map[string]string{
	"name":           "description.Interface.Name",
	"resource_group": "description.ResourceGroup",
}

func GetNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkInterface")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkInterfacePaginator(buildFilter(d.KeyColumnQuals, getNetworkInterfaceFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkInterface =============================

// ==========================  START: NetworkWatcherFlowLog =============================

type NetworkWatcherFlowLog struct {
	Description azure.NetworkWatcherFlowLogDescription `json:"description"`
	Metadata    azure.Metadata                         `json:"metadata"`
}

type NetworkWatcherFlowLogHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  NetworkWatcherFlowLog `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type NetworkWatcherFlowLogHits struct {
	Total SearchTotal                `json:"total"`
	Hits  []NetworkWatcherFlowLogHit `json:"hits"`
}

type NetworkWatcherFlowLogSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  NetworkWatcherFlowLogHits `json:"hits"`
}

type NetworkWatcherFlowLogPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewNetworkWatcherFlowLogPaginator(filters []BoolFilter, limit *int64) (NetworkWatcherFlowLogPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_network_networkwatchers", filters, limit)
	if err != nil {
		return NetworkWatcherFlowLogPaginator{}, err
	}

	p := NetworkWatcherFlowLogPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p NetworkWatcherFlowLogPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *NetworkWatcherFlowLogPaginator) NextPage(ctx context.Context) ([]NetworkWatcherFlowLog, error) {
	var response NetworkWatcherFlowLogSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkWatcherFlowLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkWatcherFlowLogFilters = map[string]string{}

func ListNetworkWatcherFlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkWatcherFlowLog")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewNetworkWatcherFlowLogPaginator(buildFilter(d.KeyColumnQuals, listNetworkWatcherFlowLogFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkWatcherFlowLogFilters = map[string]string{
	"name":                 "description.ManagedCluster.Name",
	"network_watcher_name": "",
	"resource_group":       "description.ResourceGroup",
}

func GetNetworkWatcherFlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkWatcherFlowLog")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkWatcherFlowLogPaginator(buildFilter(d.KeyColumnQuals, getNetworkWatcherFlowLogFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkWatcherFlowLog =============================

// ==========================  START: PolicyAssignment =============================

type PolicyAssignment struct {
	Description azure.PolicyAssignmentDescription `json:"description"`
	Metadata    azure.Metadata                    `json:"metadata"`
}

type PolicyAssignmentHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PolicyAssignment `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PolicyAssignmentHits struct {
	Total SearchTotal           `json:"total"`
	Hits  []PolicyAssignmentHit `json:"hits"`
}

type PolicyAssignmentSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PolicyAssignmentHits `json:"hits"`
}

type PolicyAssignmentPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewPolicyAssignmentPaginator(filters []BoolFilter, limit *int64) (PolicyAssignmentPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_authorization_policyassignments", filters, limit)
	if err != nil {
		return PolicyAssignmentPaginator{}, err
	}

	p := PolicyAssignmentPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p PolicyAssignmentPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *PolicyAssignmentPaginator) NextPage(ctx context.Context) ([]PolicyAssignment, error) {
	var response PolicyAssignmentSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PolicyAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listPolicyAssignmentFilters = map[string]string{}

func ListPolicyAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPolicyAssignment")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewPolicyAssignmentPaginator(buildFilter(d.KeyColumnQuals, listPolicyAssignmentFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPolicyAssignmentFilters = map[string]string{
	"name": "description.Assignment.Name",
}

func GetPolicyAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPolicyAssignment")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPolicyAssignmentPaginator(buildFilter(d.KeyColumnQuals, getPolicyAssignmentFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PolicyAssignment =============================

// ==========================  START: RedisCache =============================

type RedisCache struct {
	Description azure.RedisCacheDescription `json:"description"`
	Metadata    azure.Metadata              `json:"metadata"`
}

type RedisCacheHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RedisCache    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RedisCacheHits struct {
	Total SearchTotal     `json:"total"`
	Hits  []RedisCacheHit `json:"hits"`
}

type RedisCacheSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RedisCacheHits `json:"hits"`
}

type RedisCachePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewRedisCachePaginator(filters []BoolFilter, limit *int64) (RedisCachePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_cache_redis", filters, limit)
	if err != nil {
		return RedisCachePaginator{}, err
	}

	p := RedisCachePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p RedisCachePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *RedisCachePaginator) NextPage(ctx context.Context) ([]RedisCache, error) {
	var response RedisCacheSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedisCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listRedisCacheFilters = map[string]string{}

func ListRedisCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedisCache")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewRedisCachePaginator(buildFilter(d.KeyColumnQuals, listRedisCacheFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedisCacheFilters = map[string]string{
	"name":           "description.ResourceType.Name",
	"resource_group": "description.ResourceGroup",
}

func GetRedisCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedisCache")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedisCachePaginator(buildFilter(d.KeyColumnQuals, getRedisCacheFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedisCache =============================

// ==========================  START: RoleAssignment =============================

type RoleAssignment struct {
	Description azure.RoleAssignmentDescription `json:"description"`
	Metadata    azure.Metadata                  `json:"metadata"`
}

type RoleAssignmentHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RoleAssignment `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RoleAssignmentHits struct {
	Total SearchTotal         `json:"total"`
	Hits  []RoleAssignmentHit `json:"hits"`
}

type RoleAssignmentSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RoleAssignmentHits `json:"hits"`
}

type RoleAssignmentPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewRoleAssignmentPaginator(filters []BoolFilter, limit *int64) (RoleAssignmentPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_authorization_elevateaccessroleassignment", filters, limit)
	if err != nil {
		return RoleAssignmentPaginator{}, err
	}

	p := RoleAssignmentPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p RoleAssignmentPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *RoleAssignmentPaginator) NextPage(ctx context.Context) ([]RoleAssignment, error) {
	var response RoleAssignmentSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RoleAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listRoleAssignmentFilters = map[string]string{}

func ListRoleAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoleAssignment")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewRoleAssignmentPaginator(buildFilter(d.KeyColumnQuals, listRoleAssignmentFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoleAssignmentFilters = map[string]string{
	"id": "description.RoleAssignment.ID",
}

func GetRoleAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoleAssignment")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoleAssignmentPaginator(buildFilter(d.KeyColumnQuals, getRoleAssignmentFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RoleAssignment =============================

// ==========================  START: SecurityCenterSubscriptionPricing =============================

type SecurityCenterSubscriptionPricing struct {
	Description azure.SecurityCenterSubscriptionPricingDescription `json:"description"`
	Metadata    azure.Metadata                                     `json:"metadata"`
}

type SecurityCenterSubscriptionPricingHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  SecurityCenterSubscriptionPricing `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type SecurityCenterSubscriptionPricingHits struct {
	Total SearchTotal                            `json:"total"`
	Hits  []SecurityCenterSubscriptionPricingHit `json:"hits"`
}

type SecurityCenterSubscriptionPricingSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  SecurityCenterSubscriptionPricingHits `json:"hits"`
}

type SecurityCenterSubscriptionPricingPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewSecurityCenterSubscriptionPricingPaginator(filters []BoolFilter, limit *int64) (SecurityCenterSubscriptionPricingPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_security_pricings", filters, limit)
	if err != nil {
		return SecurityCenterSubscriptionPricingPaginator{}, err
	}

	p := SecurityCenterSubscriptionPricingPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p SecurityCenterSubscriptionPricingPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *SecurityCenterSubscriptionPricingPaginator) NextPage(ctx context.Context) ([]SecurityCenterSubscriptionPricing, error) {
	var response SecurityCenterSubscriptionPricingSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterSubscriptionPricing
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterSubscriptionPricingFilters = map[string]string{}

func ListSecurityCenterSubscriptionPricing(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterSubscriptionPricing")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewSecurityCenterSubscriptionPricingPaginator(buildFilter(d.KeyColumnQuals, listSecurityCenterSubscriptionPricingFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterSubscriptionPricingFilters = map[string]string{
	"name": "description.Pricing.Name",
}

func GetSecurityCenterSubscriptionPricing(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterSubscriptionPricing")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterSubscriptionPricingPaginator(buildFilter(d.KeyColumnQuals, getSecurityCenterSubscriptionPricingFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterSubscriptionPricing =============================

// ==========================  START: VirtualNetwork =============================

type VirtualNetwork struct {
	Description azure.VirtualNetworkDescription `json:"description"`
	Metadata    azure.Metadata                  `json:"metadata"`
}

type VirtualNetworkHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  VirtualNetwork `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type VirtualNetworkHits struct {
	Total SearchTotal         `json:"total"`
	Hits  []VirtualNetworkHit `json:"hits"`
}

type VirtualNetworkSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  VirtualNetworkHits `json:"hits"`
}

type VirtualNetworkPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewVirtualNetworkPaginator(filters []BoolFilter, limit *int64) (VirtualNetworkPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_network_virtualnetworks", filters, limit)
	if err != nil {
		return VirtualNetworkPaginator{}, err
	}

	p := VirtualNetworkPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p VirtualNetworkPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *VirtualNetworkPaginator) NextPage(ctx context.Context) ([]VirtualNetwork, error) {
	var response VirtualNetworkSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualNetwork
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualNetworkFilters = map[string]string{}

func ListVirtualNetwork(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualNetwork")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewVirtualNetworkPaginator(buildFilter(d.KeyColumnQuals, listVirtualNetworkFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVirtualNetworkFilters = map[string]string{
	"name":           "description.VirtualNetwork.Name",
	"resource_group": "description.ResourceGroup",
}

func GetVirtualNetwork(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualNetwork")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVirtualNetworkPaginator(buildFilter(d.KeyColumnQuals, getVirtualNetworkFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VirtualNetwork =============================

// ==========================  START: ApplicationGateway =============================

type ApplicationGateway struct {
	Description azure.ApplicationGatewayDescription `json:"description"`
	Metadata    azure.Metadata                      `json:"metadata"`
}

type ApplicationGatewayHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ApplicationGateway `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ApplicationGatewayHits struct {
	Total SearchTotal             `json:"total"`
	Hits  []ApplicationGatewayHit `json:"hits"`
}

type ApplicationGatewaySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ApplicationGatewayHits `json:"hits"`
}

type ApplicationGatewayPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewApplicationGatewayPaginator(filters []BoolFilter, limit *int64) (ApplicationGatewayPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_network_applicationgateways", filters, limit)
	if err != nil {
		return ApplicationGatewayPaginator{}, err
	}

	p := ApplicationGatewayPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p ApplicationGatewayPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *ApplicationGatewayPaginator) NextPage(ctx context.Context) ([]ApplicationGateway, error) {
	var response ApplicationGatewaySearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApplicationGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listApplicationGatewayFilters = map[string]string{}

func ListApplicationGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApplicationGateway")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewApplicationGatewayPaginator(buildFilter(d.KeyColumnQuals, listApplicationGatewayFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApplicationGatewayFilters = map[string]string{
	"name":           "description.ApplicationGateway.Name",
	"resource_group": "description.ResourceGroup",
}

func GetApplicationGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApplicationGateway")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApplicationGatewayPaginator(buildFilter(d.KeyColumnQuals, getApplicationGatewayFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApplicationGateway =============================

// ==========================  START: BatchAccount =============================

type BatchAccount struct {
	Description azure.BatchAccountDescription `json:"description"`
	Metadata    azure.Metadata                `json:"metadata"`
}

type BatchAccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BatchAccount  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BatchAccountHits struct {
	Total SearchTotal       `json:"total"`
	Hits  []BatchAccountHit `json:"hits"`
}

type BatchAccountSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  BatchAccountHits `json:"hits"`
}

type BatchAccountPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewBatchAccountPaginator(filters []BoolFilter, limit *int64) (BatchAccountPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_batch_batchaccounts", filters, limit)
	if err != nil {
		return BatchAccountPaginator{}, err
	}

	p := BatchAccountPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p BatchAccountPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *BatchAccountPaginator) NextPage(ctx context.Context) ([]BatchAccount, error) {
	var response BatchAccountSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listBatchAccountFilters = map[string]string{}

func ListBatchAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchAccount")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewBatchAccountPaginator(buildFilter(d.KeyColumnQuals, listBatchAccountFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBatchAccountFilters = map[string]string{
	"name":           "description.Account.Name",
	"resource_group": "description.ResourceGroup",
}

func GetBatchAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchAccount")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBatchAccountPaginator(buildFilter(d.KeyColumnQuals, getBatchAccountFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BatchAccount =============================

// ==========================  START: ContainerRegistry =============================

type ContainerRegistry struct {
	Description azure.ContainerRegistryDescription `json:"description"`
	Metadata    azure.Metadata                     `json:"metadata"`
}

type ContainerRegistryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ContainerRegistry `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ContainerRegistryHits struct {
	Total SearchTotal            `json:"total"`
	Hits  []ContainerRegistryHit `json:"hits"`
}

type ContainerRegistrySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ContainerRegistryHits `json:"hits"`
}

type ContainerRegistryPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewContainerRegistryPaginator(filters []BoolFilter, limit *int64) (ContainerRegistryPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_containerregistry_registries", filters, limit)
	if err != nil {
		return ContainerRegistryPaginator{}, err
	}

	p := ContainerRegistryPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p ContainerRegistryPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *ContainerRegistryPaginator) NextPage(ctx context.Context) ([]ContainerRegistry, error) {
	var response ContainerRegistrySearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerRegistry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listContainerRegistryFilters = map[string]string{}

func ListContainerRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerRegistry")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewContainerRegistryPaginator(buildFilter(d.KeyColumnQuals, listContainerRegistryFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getContainerRegistryFilters = map[string]string{
	"name":           "description.Registry.Name",
	"resource_group": "description.ResourceGroup",
}

func GetContainerRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerRegistry")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewContainerRegistryPaginator(buildFilter(d.KeyColumnQuals, getContainerRegistryFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ContainerRegistry =============================

// ==========================  START: DataFactory =============================

type DataFactory struct {
	Description azure.DataFactoryDescription `json:"description"`
	Metadata    azure.Metadata               `json:"metadata"`
}

type DataFactoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DataFactory   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DataFactoryHits struct {
	Total SearchTotal      `json:"total"`
	Hits  []DataFactoryHit `json:"hits"`
}

type DataFactorySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  DataFactoryHits `json:"hits"`
}

type DataFactoryPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewDataFactoryPaginator(filters []BoolFilter, limit *int64) (DataFactoryPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_datafactory_datafactories", filters, limit)
	if err != nil {
		return DataFactoryPaginator{}, err
	}

	p := DataFactoryPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p DataFactoryPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *DataFactoryPaginator) NextPage(ctx context.Context) ([]DataFactory, error) {
	var response DataFactorySearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataFactory
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listDataFactoryFilters = map[string]string{}

func ListDataFactory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataFactory")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewDataFactoryPaginator(buildFilter(d.KeyColumnQuals, listDataFactoryFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataFactoryFilters = map[string]string{
	"name":           "description.Factory.Name",
	"resource_group": "description.ResourceGroup",
}

func GetDataFactory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataFactory")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataFactoryPaginator(buildFilter(d.KeyColumnQuals, getDataFactoryFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataFactory =============================

// ==========================  START: DataLakeStore =============================

type DataLakeStore struct {
	Description azure.DataLakeStoreDescription `json:"description"`
	Metadata    azure.Metadata                 `json:"metadata"`
}

type DataLakeStoreHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DataLakeStore `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DataLakeStoreHits struct {
	Total SearchTotal        `json:"total"`
	Hits  []DataLakeStoreHit `json:"hits"`
}

type DataLakeStoreSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  DataLakeStoreHits `json:"hits"`
}

type DataLakeStorePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewDataLakeStorePaginator(filters []BoolFilter, limit *int64) (DataLakeStorePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_datalakestore_accounts", filters, limit)
	if err != nil {
		return DataLakeStorePaginator{}, err
	}

	p := DataLakeStorePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p DataLakeStorePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *DataLakeStorePaginator) NextPage(ctx context.Context) ([]DataLakeStore, error) {
	var response DataLakeStoreSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataLakeStore
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listDataLakeStoreFilters = map[string]string{}

func ListDataLakeStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataLakeStore")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewDataLakeStorePaginator(buildFilter(d.KeyColumnQuals, listDataLakeStoreFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataLakeStoreFilters = map[string]string{
	"name":           "description.DataLakeStoreAccount.Name",
	"resource_group": "description.ResourceGroup",
}

func GetDataLakeStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataLakeStore")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataLakeStorePaginator(buildFilter(d.KeyColumnQuals, getDataLakeStoreFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataLakeStore =============================

// ==========================  START: DiagnosticSetting =============================

type DiagnosticSetting struct {
	Description azure.DiagnosticSettingDescription `json:"description"`
	Metadata    azure.Metadata                     `json:"metadata"`
}

type DiagnosticSettingHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DiagnosticSetting `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DiagnosticSettingHits struct {
	Total SearchTotal            `json:"total"`
	Hits  []DiagnosticSettingHit `json:"hits"`
}

type DiagnosticSettingSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DiagnosticSettingHits `json:"hits"`
}

type DiagnosticSettingPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewDiagnosticSettingPaginator(filters []BoolFilter, limit *int64) (DiagnosticSettingPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_insights_guestdiagnosticsettings", filters, limit)
	if err != nil {
		return DiagnosticSettingPaginator{}, err
	}

	p := DiagnosticSettingPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p DiagnosticSettingPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *DiagnosticSettingPaginator) NextPage(ctx context.Context) ([]DiagnosticSetting, error) {
	var response DiagnosticSettingSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DiagnosticSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listDiagnosticSettingFilters = map[string]string{}

func ListDiagnosticSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDiagnosticSetting")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewDiagnosticSettingPaginator(buildFilter(d.KeyColumnQuals, listDiagnosticSettingFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDiagnosticSettingFilters = map[string]string{
	"name":           "description.DiagnosticSettingsResource.Name",
	"resource_group": "description.ResourceGroup",
}

func GetDiagnosticSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDiagnosticSetting")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDiagnosticSettingPaginator(buildFilter(d.KeyColumnQuals, getDiagnosticSettingFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DiagnosticSetting =============================

// ==========================  START: Frontdoor =============================

type Frontdoor struct {
	Description azure.FrontdoorDescription `json:"description"`
	Metadata    azure.Metadata             `json:"metadata"`
}

type FrontdoorHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Frontdoor     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FrontdoorHits struct {
	Total SearchTotal    `json:"total"`
	Hits  []FrontdoorHit `json:"hits"`
}

type FrontdoorSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  FrontdoorHits `json:"hits"`
}

type FrontdoorPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewFrontdoorPaginator(filters []BoolFilter, limit *int64) (FrontdoorPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_network_frontdoors", filters, limit)
	if err != nil {
		return FrontdoorPaginator{}, err
	}

	p := FrontdoorPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p FrontdoorPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *FrontdoorPaginator) NextPage(ctx context.Context) ([]Frontdoor, error) {
	var response FrontdoorSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Frontdoor
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listFrontdoorFilters = map[string]string{}

func ListFrontdoor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFrontdoor")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewFrontdoorPaginator(buildFilter(d.KeyColumnQuals, listFrontdoorFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFrontdoorFilters = map[string]string{
	"name":           "description.FrontDoor.Name",
	"resource_group": "description.ResourceGroup",
}

func GetFrontdoor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFrontdoor")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFrontdoorPaginator(buildFilter(d.KeyColumnQuals, getFrontdoorFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Frontdoor =============================

// ==========================  START: HdinsightCluster =============================

type HdinsightCluster struct {
	Description azure.HdinsightClusterDescription `json:"description"`
	Metadata    azure.Metadata                    `json:"metadata"`
}

type HdinsightClusterHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  HdinsightCluster `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type HdinsightClusterHits struct {
	Total SearchTotal           `json:"total"`
	Hits  []HdinsightClusterHit `json:"hits"`
}

type HdinsightClusterSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  HdinsightClusterHits `json:"hits"`
}

type HdinsightClusterPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewHdinsightClusterPaginator(filters []BoolFilter, limit *int64) (HdinsightClusterPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_hdinsight_clusterpools", filters, limit)
	if err != nil {
		return HdinsightClusterPaginator{}, err
	}

	p := HdinsightClusterPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p HdinsightClusterPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *HdinsightClusterPaginator) NextPage(ctx context.Context) ([]HdinsightCluster, error) {
	var response HdinsightClusterSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HdinsightCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listHdinsightClusterFilters = map[string]string{}

func ListHdinsightCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHdinsightCluster")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewHdinsightClusterPaginator(buildFilter(d.KeyColumnQuals, listHdinsightClusterFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHdinsightClusterFilters = map[string]string{
	"name":           "description.Cluster.Name",
	"resource_group": "description.ResourceGroup",
}

func GetHdinsightCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHdinsightCluster")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHdinsightClusterPaginator(buildFilter(d.KeyColumnQuals, getHdinsightClusterFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HdinsightCluster =============================

// ==========================  START: IOTHub =============================

type IOTHub struct {
	Description azure.IOTHubDescription `json:"description"`
	Metadata    azure.Metadata          `json:"metadata"`
}

type IOTHubHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IOTHub        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IOTHubHits struct {
	Total SearchTotal `json:"total"`
	Hits  []IOTHubHit `json:"hits"`
}

type IOTHubSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  IOTHubHits `json:"hits"`
}

type IOTHubPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewIOTHubPaginator(filters []BoolFilter, limit *int64) (IOTHubPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_devices_elasticpools_iothubtenants", filters, limit)
	if err != nil {
		return IOTHubPaginator{}, err
	}

	p := IOTHubPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p IOTHubPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *IOTHubPaginator) NextPage(ctx context.Context) ([]IOTHub, error) {
	var response IOTHubSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IOTHub
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listIOTHubFilters = map[string]string{}

func ListIOTHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIOTHub")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewIOTHubPaginator(buildFilter(d.KeyColumnQuals, listIOTHubFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIOTHubFilters = map[string]string{
	"name":           "description.IotHubDescription.Name",
	"resource_group": "description.ResourceGroup",
}

func GetIOTHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIOTHub")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIOTHubPaginator(buildFilter(d.KeyColumnQuals, getIOTHubFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IOTHub =============================

// ==========================  START: KeyVault =============================

type KeyVault struct {
	Description azure.KeyVaultDescription `json:"description"`
	Metadata    azure.Metadata            `json:"metadata"`
}

type KeyVaultHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KeyVault      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KeyVaultHits struct {
	Total SearchTotal   `json:"total"`
	Hits  []KeyVaultHit `json:"hits"`
}

type KeyVaultSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  KeyVaultHits `json:"hits"`
}

type KeyVaultPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewKeyVaultPaginator(filters []BoolFilter, limit *int64) (KeyVaultPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_keyvault_hsmpools", filters, limit)
	if err != nil {
		return KeyVaultPaginator{}, err
	}

	p := KeyVaultPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p KeyVaultPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *KeyVaultPaginator) NextPage(ctx context.Context) ([]KeyVault, error) {
	var response KeyVaultSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultFilters = map[string]string{}

func ListKeyVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVault")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewKeyVaultPaginator(buildFilter(d.KeyColumnQuals, listKeyVaultFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyVaultFilters = map[string]string{
	"name":           "description.Resource.Name",
	"resource_group": "description.ResourceGroup",
}

func GetKeyVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVault")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultPaginator(buildFilter(d.KeyColumnQuals, getKeyVaultFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyVault =============================

// ==========================  START: LogAlert =============================

type LogAlert struct {
	Description azure.LogAlertDescription `json:"description"`
	Metadata    azure.Metadata            `json:"metadata"`
}

type LogAlertHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LogAlert      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LogAlertHits struct {
	Total SearchTotal   `json:"total"`
	Hits  []LogAlertHit `json:"hits"`
}

type LogAlertSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  LogAlertHits `json:"hits"`
}

type LogAlertPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewLogAlertPaginator(filters []BoolFilter, limit *int64) (LogAlertPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_insights_activitylogalerts", filters, limit)
	if err != nil {
		return LogAlertPaginator{}, err
	}

	p := LogAlertPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p LogAlertPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *LogAlertPaginator) NextPage(ctx context.Context) ([]LogAlert, error) {
	var response LogAlertSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogAlert
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listLogAlertFilters = map[string]string{}

func ListLogAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogAlert")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewLogAlertPaginator(buildFilter(d.KeyColumnQuals, listLogAlertFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLogAlertFilters = map[string]string{
	"name":           "description.ActivityLogAlertResource.Name",
	"resource_group": "description.ResourceGroup",
}

func GetLogAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogAlert")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLogAlertPaginator(buildFilter(d.KeyColumnQuals, getLogAlertFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LogAlert =============================

// ==========================  START: MariadbServer =============================

type MariadbServer struct {
	Description azure.MariadbServerDescription `json:"description"`
	Metadata    azure.Metadata                 `json:"metadata"`
}

type MariadbServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MariadbServer `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MariadbServerHits struct {
	Total SearchTotal        `json:"total"`
	Hits  []MariadbServerHit `json:"hits"`
}

type MariadbServerSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  MariadbServerHits `json:"hits"`
}

type MariadbServerPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewMariadbServerPaginator(filters []BoolFilter, limit *int64) (MariadbServerPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_dbformariadb_servers", filters, limit)
	if err != nil {
		return MariadbServerPaginator{}, err
	}

	p := MariadbServerPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p MariadbServerPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *MariadbServerPaginator) NextPage(ctx context.Context) ([]MariadbServer, error) {
	var response MariadbServerSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MariadbServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listMariadbServerFilters = map[string]string{}

func ListMariadbServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMariadbServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewMariadbServerPaginator(buildFilter(d.KeyColumnQuals, listMariadbServerFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMariadbServerFilters = map[string]string{
	"name":           "description.Server.Name",
	"resource_group": "description.ResourceGroup",
}

func GetMariadbServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMariadbServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMariadbServerPaginator(buildFilter(d.KeyColumnQuals, getMariadbServerFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MariadbServer =============================

// ==========================  START: MysqlServer =============================

type MysqlServer struct {
	Description azure.MysqlServerDescription `json:"description"`
	Metadata    azure.Metadata               `json:"metadata"`
}

type MysqlServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MysqlServer   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MysqlServerHits struct {
	Total SearchTotal      `json:"total"`
	Hits  []MysqlServerHit `json:"hits"`
}

type MysqlServerSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  MysqlServerHits `json:"hits"`
}

type MysqlServerPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewMysqlServerPaginator(filters []BoolFilter, limit *int64) (MysqlServerPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_dbformysql_servers", filters, limit)
	if err != nil {
		return MysqlServerPaginator{}, err
	}

	p := MysqlServerPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p MysqlServerPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *MysqlServerPaginator) NextPage(ctx context.Context) ([]MysqlServer, error) {
	var response MysqlServerSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MysqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listMysqlServerFilters = map[string]string{}

func ListMysqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMysqlServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewMysqlServerPaginator(buildFilter(d.KeyColumnQuals, listMysqlServerFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMysqlServerFilters = map[string]string{
	"name":           "description.Server.Name",
	"resource_group": "description.ResourceGroup",
}

func GetMysqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMysqlServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMysqlServerPaginator(buildFilter(d.KeyColumnQuals, getMysqlServerFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MysqlServer =============================

// ==========================  START: NetworkSecurityGroup =============================

type NetworkSecurityGroup struct {
	Description azure.NetworkSecurityGroupDescription `json:"description"`
	Metadata    azure.Metadata                        `json:"metadata"`
}

type NetworkSecurityGroupHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  NetworkSecurityGroup `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type NetworkSecurityGroupHits struct {
	Total SearchTotal               `json:"total"`
	Hits  []NetworkSecurityGroupHit `json:"hits"`
}

type NetworkSecurityGroupSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  NetworkSecurityGroupHits `json:"hits"`
}

type NetworkSecurityGroupPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewNetworkSecurityGroupPaginator(filters []BoolFilter, limit *int64) (NetworkSecurityGroupPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_classicnetwork_networksecuritygroups", filters, limit)
	if err != nil {
		return NetworkSecurityGroupPaginator{}, err
	}

	p := NetworkSecurityGroupPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p NetworkSecurityGroupPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *NetworkSecurityGroupPaginator) NextPage(ctx context.Context) ([]NetworkSecurityGroup, error) {
	var response NetworkSecurityGroupSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkSecurityGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkSecurityGroupFilters = map[string]string{}

func ListNetworkSecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkSecurityGroup")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewNetworkSecurityGroupPaginator(buildFilter(d.KeyColumnQuals, listNetworkSecurityGroupFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkSecurityGroupFilters = map[string]string{
	"name":           "description.SecurityGroup.Name",
	"resource_group": "description.ResourceGroup",
}

func GetNetworkSecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkSecurityGroup")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkSecurityGroupPaginator(buildFilter(d.KeyColumnQuals, getNetworkSecurityGroupFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkSecurityGroup =============================

// ==========================  START: NetworkWatcher =============================

type NetworkWatcher struct {
	Description azure.NetworkWatcherDescription `json:"description"`
	Metadata    azure.Metadata                  `json:"metadata"`
}

type NetworkWatcherHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  NetworkWatcher `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type NetworkWatcherHits struct {
	Total SearchTotal         `json:"total"`
	Hits  []NetworkWatcherHit `json:"hits"`
}

type NetworkWatcherSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  NetworkWatcherHits `json:"hits"`
}

type NetworkWatcherPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewNetworkWatcherPaginator(filters []BoolFilter, limit *int64) (NetworkWatcherPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_network_networkwatchers", filters, limit)
	if err != nil {
		return NetworkWatcherPaginator{}, err
	}

	p := NetworkWatcherPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p NetworkWatcherPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *NetworkWatcherPaginator) NextPage(ctx context.Context) ([]NetworkWatcher, error) {
	var response NetworkWatcherSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkWatcher
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkWatcherFilters = map[string]string{}

func ListNetworkWatcher(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkWatcher")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewNetworkWatcherPaginator(buildFilter(d.KeyColumnQuals, listNetworkWatcherFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkWatcherFilters = map[string]string{
	"name":           "description.Watcher.Name",
	"resource_group": "description.ResourceGroup",
}

func GetNetworkWatcher(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkWatcher")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkWatcherPaginator(buildFilter(d.KeyColumnQuals, getNetworkWatcherFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkWatcher =============================

// ==========================  START: SearchService =============================

type SearchService struct {
	Description azure.SearchServiceDescription `json:"description"`
	Metadata    azure.Metadata                 `json:"metadata"`
}

type SearchServiceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SearchService `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SearchServiceHits struct {
	Total SearchTotal        `json:"total"`
	Hits  []SearchServiceHit `json:"hits"`
}

type SearchServiceSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  SearchServiceHits `json:"hits"`
}

type SearchServicePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewSearchServicePaginator(filters []BoolFilter, limit *int64) (SearchServicePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_search_searchservices", filters, limit)
	if err != nil {
		return SearchServicePaginator{}, err
	}

	p := SearchServicePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p SearchServicePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *SearchServicePaginator) NextPage(ctx context.Context) ([]SearchService, error) {
	var response SearchServiceSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SearchService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listSearchServiceFilters = map[string]string{}

func ListSearchService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSearchService")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewSearchServicePaginator(buildFilter(d.KeyColumnQuals, listSearchServiceFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSearchServiceFilters = map[string]string{
	"name":           "description.Service.Name",
	"resource_group": "description.ResourceGroup",
}

func GetSearchService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSearchService")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSearchServicePaginator(buildFilter(d.KeyColumnQuals, getSearchServiceFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SearchService =============================

// ==========================  START: ServiceFabricCluster =============================

type ServiceFabricCluster struct {
	Description azure.ServiceFabricClusterDescription `json:"description"`
	Metadata    azure.Metadata                        `json:"metadata"`
}

type ServiceFabricClusterHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ServiceFabricCluster `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ServiceFabricClusterHits struct {
	Total SearchTotal               `json:"total"`
	Hits  []ServiceFabricClusterHit `json:"hits"`
}

type ServiceFabricClusterSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ServiceFabricClusterHits `json:"hits"`
}

type ServiceFabricClusterPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewServiceFabricClusterPaginator(filters []BoolFilter, limit *int64) (ServiceFabricClusterPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_servicefabric_clusters", filters, limit)
	if err != nil {
		return ServiceFabricClusterPaginator{}, err
	}

	p := ServiceFabricClusterPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p ServiceFabricClusterPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *ServiceFabricClusterPaginator) NextPage(ctx context.Context) ([]ServiceFabricCluster, error) {
	var response ServiceFabricClusterSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceFabricCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listServiceFabricClusterFilters = map[string]string{}

func ListServiceFabricCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceFabricCluster")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewServiceFabricClusterPaginator(buildFilter(d.KeyColumnQuals, listServiceFabricClusterFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getServiceFabricClusterFilters = map[string]string{
	"name":           "description.Cluster.Name",
	"resource_group": "description.ResourceGroup",
}

func GetServiceFabricCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceFabricCluster")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceFabricClusterPaginator(buildFilter(d.KeyColumnQuals, getServiceFabricClusterFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ServiceFabricCluster =============================

// ==========================  START: SignalrService =============================

type SignalrService struct {
	Description azure.SignalrServiceDescription `json:"description"`
	Metadata    azure.Metadata                  `json:"metadata"`
}

type SignalrServiceHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SignalrService `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SignalrServiceHits struct {
	Total SearchTotal         `json:"total"`
	Hits  []SignalrServiceHit `json:"hits"`
}

type SignalrServiceSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SignalrServiceHits `json:"hits"`
}

type SignalrServicePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewSignalrServicePaginator(filters []BoolFilter, limit *int64) (SignalrServicePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_signalrservice_signalr", filters, limit)
	if err != nil {
		return SignalrServicePaginator{}, err
	}

	p := SignalrServicePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p SignalrServicePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *SignalrServicePaginator) NextPage(ctx context.Context) ([]SignalrService, error) {
	var response SignalrServiceSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SignalrService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listSignalrServiceFilters = map[string]string{}

func ListSignalrService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSignalrService")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewSignalrServicePaginator(buildFilter(d.KeyColumnQuals, listSignalrServiceFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSignalrServiceFilters = map[string]string{
	"name":           "description.ResourceType.Name",
	"resource_group": "description.ResourceGroup",
}

func GetSignalrService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSignalrService")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSignalrServicePaginator(buildFilter(d.KeyColumnQuals, getSignalrServiceFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SignalrService =============================

// ==========================  START: StreamAnalyticsJob =============================

type StreamAnalyticsJob struct {
	Description azure.StreamAnalyticsJobDescription `json:"description"`
	Metadata    azure.Metadata                      `json:"metadata"`
}

type StreamAnalyticsJobHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  StreamAnalyticsJob `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type StreamAnalyticsJobHits struct {
	Total SearchTotal             `json:"total"`
	Hits  []StreamAnalyticsJobHit `json:"hits"`
}

type StreamAnalyticsJobSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  StreamAnalyticsJobHits `json:"hits"`
}

type StreamAnalyticsJobPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewStreamAnalyticsJobPaginator(filters []BoolFilter, limit *int64) (StreamAnalyticsJobPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_streamanalytics_streamingjobs", filters, limit)
	if err != nil {
		return StreamAnalyticsJobPaginator{}, err
	}

	p := StreamAnalyticsJobPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p StreamAnalyticsJobPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *StreamAnalyticsJobPaginator) NextPage(ctx context.Context) ([]StreamAnalyticsJob, error) {
	var response StreamAnalyticsJobSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StreamAnalyticsJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listStreamAnalyticsJobFilters = map[string]string{}

func ListStreamAnalyticsJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStreamAnalyticsJob")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewStreamAnalyticsJobPaginator(buildFilter(d.KeyColumnQuals, listStreamAnalyticsJobFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStreamAnalyticsJobFilters = map[string]string{
	"name":           "description.StreamingJob.Name",
	"resource_group": "description.ResourceGroup",
}

func GetStreamAnalyticsJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStreamAnalyticsJob")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStreamAnalyticsJobPaginator(buildFilter(d.KeyColumnQuals, getStreamAnalyticsJobFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StreamAnalyticsJob =============================

// ==========================  START: Location =============================

type Location struct {
	Description azure.LocationDescription `json:"description"`
	Metadata    azure.Metadata            `json:"metadata"`
}

type LocationHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Location      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LocationHits struct {
	Total SearchTotal   `json:"total"`
	Hits  []LocationHit `json:"hits"`
}

type LocationSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  LocationHits `json:"hits"`
}

type LocationPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewLocationPaginator(filters []BoolFilter, limit *int64) (LocationPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_desktopvirtualization_hostpools_sessionhosts", filters, limit)
	if err != nil {
		return LocationPaginator{}, err
	}

	p := LocationPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p LocationPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *LocationPaginator) NextPage(ctx context.Context) ([]Location, error) {
	var response LocationSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Location
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listLocationFilters = map[string]string{}

func ListLocation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLocation")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewLocationPaginator(buildFilter(d.KeyColumnQuals, listLocationFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLocationFilters = map[string]string{
	"name":           "description.Location.Name",
	"resource_group": "description.ResourceGroup",
}

func GetLocation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLocation")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLocationPaginator(buildFilter(d.KeyColumnQuals, getLocationFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Location =============================

// ==========================  START: PostgresqlServer =============================

type PostgresqlServer struct {
	Description azure.PostgresqlServerDescription `json:"description"`
	Metadata    azure.Metadata                    `json:"metadata"`
}

type PostgresqlServerHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PostgresqlServer `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PostgresqlServerHits struct {
	Total SearchTotal           `json:"total"`
	Hits  []PostgresqlServerHit `json:"hits"`
}

type PostgresqlServerSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PostgresqlServerHits `json:"hits"`
}

type PostgresqlServerPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewPostgresqlServerPaginator(filters []BoolFilter, limit *int64) (PostgresqlServerPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_dbforpostgresql_servergroups", filters, limit)
	if err != nil {
		return PostgresqlServerPaginator{}, err
	}

	p := PostgresqlServerPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p PostgresqlServerPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *PostgresqlServerPaginator) NextPage(ctx context.Context) ([]PostgresqlServer, error) {
	var response PostgresqlServerSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PostgresqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listPostgresqlServerFilters = map[string]string{}

func ListPostgresqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPostgresqlServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewPostgresqlServerPaginator(buildFilter(d.KeyColumnQuals, listPostgresqlServerFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPostgresqlServerFilters = map[string]string{
	"name":           "description.Server.Name",
	"resource_group": "description.ResourceGroup",
}

func GetPostgresqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPostgresqlServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPostgresqlServerPaginator(buildFilter(d.KeyColumnQuals, getPostgresqlServerFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PostgresqlServer =============================

// ==========================  START: StorageSync =============================

type StorageSync struct {
	Description azure.StorageSyncDescription `json:"description"`
	Metadata    azure.Metadata               `json:"metadata"`
}

type StorageSyncHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageSync   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageSyncHits struct {
	Total SearchTotal      `json:"total"`
	Hits  []StorageSyncHit `json:"hits"`
}

type StorageSyncSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  StorageSyncHits `json:"hits"`
}

type StorageSyncPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewStorageSyncPaginator(filters []BoolFilter, limit *int64) (StorageSyncPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_storagesync_storagesyncservices", filters, limit)
	if err != nil {
		return StorageSyncPaginator{}, err
	}

	p := StorageSyncPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p StorageSyncPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *StorageSyncPaginator) NextPage(ctx context.Context) ([]StorageSync, error) {
	var response StorageSyncSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageSync
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listStorageSyncFilters = map[string]string{}

func ListStorageSync(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageSync")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewStorageSyncPaginator(buildFilter(d.KeyColumnQuals, listStorageSyncFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageSyncFilters = map[string]string{
	"name":           "description.Service.Name",
	"resource_group": "description.ResourceGroup",
}

func GetStorageSync(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageSync")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageSyncPaginator(buildFilter(d.KeyColumnQuals, getStorageSyncFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageSync =============================

// ==========================  START: SqlDatabase =============================

type SqlDatabase struct {
	Description azure.SqlDatabaseDescription `json:"description"`
	Metadata    azure.Metadata               `json:"metadata"`
}

type SqlDatabaseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SqlDatabase   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SqlDatabaseHits struct {
	Total SearchTotal      `json:"total"`
	Hits  []SqlDatabaseHit `json:"hits"`
}

type SqlDatabaseSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SqlDatabaseHits `json:"hits"`
}

type SqlDatabasePaginator struct {
	paginator baseESPaginator
}

func (k Client) NewSqlDatabasePaginator(filters []BoolFilter, limit *int64) (SqlDatabasePaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_synapse_workspaces_sqldatabases", filters, limit)
	if err != nil {
		return SqlDatabasePaginator{}, err
	}

	p := SqlDatabasePaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p SqlDatabasePaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *SqlDatabasePaginator) NextPage(ctx context.Context) ([]SqlDatabase, error) {
	var response SqlDatabaseSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listSqlDatabaseFilters = map[string]string{}

func ListSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlDatabase")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewSqlDatabasePaginator(buildFilter(d.KeyColumnQuals, listSqlDatabaseFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlDatabaseFilters = map[string]string{
	"name":           "description.Database.Name",
	"resource_group": "description.ResourceGroup",
}

func GetSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlDatabase")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlDatabasePaginator(buildFilter(d.KeyColumnQuals, getSqlDatabaseFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlDatabase =============================

// ==========================  START: SqlServer =============================

type SqlServer struct {
	Description azure.SqlServerDescription `json:"description"`
	Metadata    azure.Metadata             `json:"metadata"`
}

type SqlServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SqlServer     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SqlServerHits struct {
	Total SearchTotal    `json:"total"`
	Hits  []SqlServerHit `json:"hits"`
}

type SqlServerSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  SqlServerHits `json:"hits"`
}

type SqlServerPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewSqlServerPaginator(filters []BoolFilter, limit *int64) (SqlServerPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_azurearcdata_sqlserverinstances", filters, limit)
	if err != nil {
		return SqlServerPaginator{}, err
	}

	p := SqlServerPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p SqlServerPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *SqlServerPaginator) NextPage(ctx context.Context) ([]SqlServer, error) {
	var response SqlServerSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerFilters = map[string]string{}

func ListSqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewSqlServerPaginator(buildFilter(d.KeyColumnQuals, listSqlServerFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlServerFilters = map[string]string{
	"name":           "description.Server.Name",
	"resource_group": "description.ResourceGroup",
}

func GetSqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServer")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlServerPaginator(buildFilter(d.KeyColumnQuals, getSqlServerFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlServer =============================

// ==========================  START: StorageAccount =============================

type StorageAccount struct {
	Description azure.StorageAccountDescription `json:"description"`
	Metadata    azure.Metadata                  `json:"metadata"`
}

type StorageAccountHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  StorageAccount `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type StorageAccountHits struct {
	Total SearchTotal         `json:"total"`
	Hits  []StorageAccountHit `json:"hits"`
}

type StorageAccountSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  StorageAccountHits `json:"hits"`
}

type StorageAccountPaginator struct {
	paginator baseESPaginator
}

func (k Client) NewStorageAccountPaginator(filters []BoolFilter, limit *int64) (StorageAccountPaginator, error) {
	paginator, err := newPaginator(k.es, "microsoft_classicstorage_storageaccounts", filters, limit)
	if err != nil {
		return StorageAccountPaginator{}, err
	}

	p := StorageAccountPaginator{
		paginator: *paginator,
	}

	return p, nil
}

func (p StorageAccountPaginator) HasNext() bool {
	return !p.paginator.done
}

func (p *StorageAccountPaginator) NextPage(ctx context.Context) ([]StorageAccount, error) {
	var response StorageAccountSearchResponse
	err := p.paginator.search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.updateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.updateState(hits, nil, "")
	}

	return values, nil
}

var listStorageAccountFilters = map[string]string{}

func ListStorageAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageAccount")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	paginator, err := k.NewStorageAccountPaginator(buildFilter(d.KeyColumnQuals, listStorageAccountFilters), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageAccountFilters = map[string]string{
	"name":           "description.Account.Name",
	"resource_group": "description.ResourceGroup",
}

func GetStorageAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageAccount")

	// create service
	k, err := NewClient(GetConfig(d.Connection))
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageAccountPaginator(buildFilter(d.KeyColumnQuals, getStorageAccountFilters), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageAccount =============================
